// Copyright (c) 2020 Nicholas Corgan
// SPDX-License-Identifier: BSL-1.0

#pragma once

#include <Pothos/System/HostInfo.hpp>

#include <algorithm>
#include <cstdlib>
#include <iostream>
#include <string>
#include <unordered_map>

#define ARCH_FUNCTION_DECL(SIMDArch) namespace @NAMESPACE_DECL@ { namespace SIMDArch { @FUNCTION_DECL@ } }
#define ARCH_MAP_ENTRY(SIMDArch) {#SIMDArch, &@NAMESPACE_DECL@::SIMDArch::@SHORT_NAME@<T>},

@ALL_ARCH_DECLS@

namespace @NAMESPACE_DECL@
{

template <typename T>
using @SHORT_NAME@Fcn = decltype(&@NAMESPACE_DECL@::fallback::@SHORT_NAME@<T>);

template <typename T>
static @SHORT_NAME@Fcn<T> @SHORT_NAME@Dispatch()
{
    static const std::unordered_map<std::string, @SHORT_NAME@Fcn<T>> Impls =
    {
        @ALL_ARCH_MAP_ENTRIES@

        ARCH_MAP_ENTRY(fallback)
    };

    using MapPair = typename std::unordered_map<std::string, @SHORT_NAME@Fcn<T>>::value_type;

    const auto arches = Pothos::System::HostInfo::get().availableSIMDArchitectures;
    for(const auto& arch: arches)
    {
        auto count = std::count_if(
                           Impls.begin(),
                           Impls.end(),
                           [&arch](const MapPair& mapPair)
                           {
                               std::cout << "Searching " << mapPair.first << " for " << arch << std::endl;
                               return (mapPair.first.find(arch) != std::string::npos);
                           });
        std::cout << "arch: found in " << count << std::endl;

        auto mapIter = std::find_if(
                           Impls.begin(),
                           Impls.end(),
                           [&arch](const MapPair& mapPair)
                           {
                               std::cout << "Searching " << mapPair.first << " for " << arch << std::endl;
                               return (mapPair.first.find(arch) != std::string::npos);
                           });
        if(mapIter != Impls.end()) return mapIter->second;
    }

    // We couldn't find an applicable one, so go with the fallback function,
    // which should be roughly as performant as the default Pothos implementation.
    return Impls.at("fallback");
}

}
