// Copyright (c) 2020 Nicholas Corgan
// SPDX-License-Identifier: BSL-1.0

#pragma once

#include <Pothos/System/HostInfo.hpp>
#include <Pothos/System/SIMD.hpp>

#include <algorithm>
#include <cstdlib>
#include <iostream>
#include <string>
#include <unordered_map>

#define ARCH_FUNCTION_DECL(SIMDArch) namespace @NAMESPACE_DECL@ { namespace SIMDArch { @FUNCTION_DECL@ } }
#define ARCH_MAP_ENTRY(SIMDArch) {#SIMDArch, &@NAMESPACE_DECL@::SIMDArch::@SHORT_NAME@<T>},

@ALL_ARCH_DECLS@

namespace @NAMESPACE_DECL@
{

template <typename T>
using @SHORT_NAME@Fcn = decltype(&@NAMESPACE_DECL@::fallback::@SHORT_NAME@<T>);

template <typename T>
static @SHORT_NAME@Fcn<T> @SHORT_NAME@Dispatch()
{
    static const std::unordered_map<std::string, @SHORT_NAME@Fcn<T>> Impls =
    {
        @ALL_ARCH_MAP_ENTRIES@

        ARCH_MAP_ENTRY(fallback)
    };
    static const std::vector<std::string> Keys = {@ALL_ARCHS@};

    auto arch = Pothos::System::getOptimalSIMDFeatureSetKey(Keys);

    // In theory, the function should return the callback function in this case,
    // but account for it here to be safe.
    auto implIter = Impls.find(arch);
    if(implIter != Impls.end()) return implIter->second;
    else                        return Impls.at("fallback");
}

}
